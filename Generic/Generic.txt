<1>
ArrayList의 인스턴스를 생성할때 다음과같이 쓴다. ArrayList<타입> 객체명 = new ArrayList<타입>(); 
안에 들어가는 타입은 String , Integer등 상황에 따라 바뀌는데 이것이 바뀔수 있는 이유가 Generic을 사용해서이다.

예를들어 우리가 새로운 자료구조 A를 만들었다고 하자. 이 자료구조는 String 타입도 지원하고 싶고 Integer 타입도 지원하고 싶고 내가 새롭게 만든 Data 타입도 지원하게 해주고싶다.
그렇다면 우리는 A를 String으로 지원하는 클래스를 만들고, Integer로 지원하는 클래스를 만들고, 내가 만든 Data를 지원하는 클래스를 모두 만들어야할까?
이런 비효율적인 문제를 해결하기 위해서 클래스 내부에서 타입을 지정하는 것이 아닌 외부에서 사용자에 의해 지정되게 만들어준다.
바로 이것이 Generic이다.

제네릭을 사용하게 되면 잘못된 타입이 들어오는 것을 컴파일 단계에서 방지할 수 있습니다.

<2>
만약에 다음과 같이 User, Id 데이터들을 만들고 다음과같이 코드를 작성해도 컴파일 단계에서는 문제가 없습니다.
하지만 직접 실행해보면 다음과 같이 에러가 나옵니다.

java.lang.ClassCastException

클래스의 자료형을 캐스팅하는 과정에서  에러가 발생한 것이다.
User의 생성자는 매개변수 info의 데이터 타입이 Object라서 모든 객체가 될 수 있다. 따라서 String이 와도 컴파일 에러가 발생하지 않는다.
하지만 직접 실행해보면 JVM이 캐스팅을 하는 과정에서 오류를 일으키게됩니다.

이 코드를 제네릭을 이용해서 바꿔봅시다.
<3>
보통 제네릭은 다음과 같은 형태로 사용됩니다
public class 클래스이름<T> {

      private T 변수명;
      //...

      public T 메소드명() {
      }

      public void 메소드명(T 변수명) {
      }

     //...

}

그래서 이 형태대로 User를 바꾸고 바뀐 User에 맞춰서 메인에서 코드를 수정해줍니다.
이렇게 하면 들어가야 하는 타입을 컴파일 단계에서 검출할 수 있어서 타입의 안정성을 추구할 수 있게됩니다.

또 제네릭은 여러개를 사용할 수 있습니다.
<4>
이번에는 User에 location을 추가해봅시다.

제네릭에서 사용하는 매개변수들의 대표적인 사용 예시들은 다음과 같습니다.
E - Element (used extensively by the Java Collections Framework)
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types

우리는 2번째 타입으로 추가되므로 S로 매개변수를 사용해봅시다.

다음과 같이 User를 수정해주고 Address 클래스를 만들어서 location에 들어갈 클래스를 생성해줍니다.
그 다음 메인에서 코드를 수정해줍시다.
다음과 같이 수정하면 정상적으로 User에서 ID와 Address를 가져오게됩니다.

제네릭에 대한 자세한 사항은 
https://opentutorials.org/module/516/6237 에서 공부해보길 바랍니다.