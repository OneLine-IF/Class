<1>
아키텍쳐에 대해 배워봅시다.
이 ppt에서는 아키텍쳐 패턴이란 무엇인지, 안드로이드에서 사용되는 것들은 무엇인지에 대해서 배울 것 입니다.

<2>
아키텍쳐 패턴이란 무엇일까요?

우리가 안드로이드를 개발을 하다보면 규모가 굉장히 커지게 됩니다.
클래스도 10개, 20개, 50개, 100개가 넘을 수 있겠죠?
그렇다면 이렇게 큰 규모의 프로젝트에서 유지보수를 한다고 하면 자신이 친 코드를 빠르게 찾을 수 있을까요?
그리고 우리는 보통 이렇게 큰 프로젝트는 협업을 하게됩니다. 그렇다면 협업하는 동료들을 코드들을 빠르게 찾을 수 있을까요?
동료들이 내 코드를 빠르게 찾을 수 있을까요?
그리고 지금처럼 액티비티나 프래그먼트에 모든 기능들을 넣어놓는식으로 개발을 하다보면 코드가 굉장히 길어지게됩니다.
그러면 내가 수정하려는 기능이 어디있는지 찾는데도 오래걸리겠죠?

그래서 이러한 어려움들을 해결하기 위해서 분리를 하기 시작합니다.
액티비티나 프래그먼트에 있던 기능들을 UI는 UI대로, 로직은 로직대로, 생성한 객체들은 객체대로 따로따로 분류를 합니다.
그러한 과정에서 과거의 개발자들이 생각할때 이 구조로 코드들을 관리하면 좋더라 이 구조로 코드들을 관리하면 어떤 장점이 있더라 하면서 여러가지 구조들을 만들게 됩니다.
이를 통틀어 아키텍쳐 패턴이라고 합니다. 한 마디로 요약하자면 코드들을 효율적으로 관리하기 위한 구조 설계법이라고 할 수 있겠네요.

<3>
그럼 안드로이드에서는 무엇을 자주 사용하는지 알아봅시다.
아키텍쳐 패턴에는 MVC, MVP, MVVM이 주로 사용됩니다.

<4>.
우리가 안드로이드에서 기본적으로 사용하고있는 패턴이 바로 MVC입니다.
구조는 Model, View, Controller로 되어있습니다.

<5>
Model은 보통 우리가 사용하는 데이터, 상태, 데이터를 가공하는 로직등을 말합니다.
프로젝트 내에서 쓰이는 데이터를 저장, 가공, 처리하는 역할을 합니다.
예시를 들자면 다음과 같이 사용되는것이 바로 Model입니다.

<6>
View는 보통 UI를 의미합니다. MVC 패턴에서는 xml을 의미하는데, 패턴마다 View의 개념이 조금씩 달라집니다.

<7>
Controller는 Model과 VIew를 연결해주고 유저에게 액션을 받으면 처리하는 역할을 합니다.
Activity, Fragment라고 볼 수 있겠네요. 그림처럼 UI에 기능들을 달아주고 액션이 들어오면 온클릭 리스너에 해당하는 작업이 하도록 연결해주고 있네요.

MVC패턴은 코드가 짧을때는 한눈에 코드를 파악하기 쉽겠지만, 코드들이 분리가 안되어있어서 View와 Model사이의 결합도가 높아 유지보수하기 힘들다는 단점이 있습니다.  

<8>
그래서 이를 보완하고자 만들어진 것이 MVP 패턴입니다.
MVP 패턴은 Model, View, Presenter로 구성됩니다.
View와 Model이 Presenter를 통해서 동작할 수 있도록해서 View와 Model의 의존성을 제거합니다.
Model은 이전 MVC패턴과 같고 View가 좀 달라집니다.
이전에 Controller에 해당하던 것들이 View에 넘어오고 View를 관리하는 인터페이스를 추가해서 Presenter가 독립적일 수 있게 해줍니다.

<9>
실제로 예시 프로젝트를 보면서 차근차근 살펴봅시다.
예시 프로젝트는 시간조회 버튼을 누르면 현재 시간을 가져와서 보여주는 프로젝트입니다.

왼쪽에 노란색 네모안에 있는 것들이 이 MVP 패턴의 기초입니다.
Model에 Time, View에 MainActivity, Presenter에 Presenter 클래스가 각각 담당하고 Contract란 인터페이스를 사용하여 패턴을 좀 더 쉽게 사용하고 이해할 수 있게 도와줍니다.

먼저 View를 봅시다. View에는 view와 관련된 기능들만 포함됩니다. presenter.getCurrentTime 메소드에서 현재시각을 가져오는 로직을 처리합니다.
그렇다면 changeText 메소드는 어디서 나온것일까요?
MainActivity의 상단에 implements Contract.View라고 써져있는것을 볼 수 있습니다.
인터페이스에서 상속받은 changeText 메소드를 재정의해서 사용하는 것을 알 수 있습니다.
<10>
자 그럼 Contract 인터페이스를 봅시다.
View와 Presenter로 두개가 나뉘어 있습니다. View에서는 changeText를, Presenter에서는 getCurrentTime을 상속할 수 있네요.
그럼 View와 Presenter에서 할 일들이 Contract에서 작성되니까 우리는 Contract에서 각각이 어떻게 작동하는지를 간단히 알 수 있겠네요.

다음은 Presenter를 봅시다.
<11>
Presenter에서는 Contract의 Presenter를 부분의 getCurrentTime을 상속받아 데이터를 처리합니다. Model인 Time에 setTime 메소드를 사용하고, view에 changeText 메소드를 사용해서 model과 view를 연결시켜주는 역할을 하고있죠?

<12>
다음은 Model입니다.
보통 사용하는 Model에 setTime이란 로직이 추가된 경우입니다. Model에는 언제든지 로직이 추가될 수 있다는 점 알아두세요.

그래서 실행을 해보면 시간조회 버튼을 누르면 정상적으로 시간이 불러와 지는 것을 알 수 있습니다.

과정을 나타내보자면
버튼을 누름 -> presenter.getCurrentTime() 실행 -> 현재 시간을 불러오고 Model인 time에 시간설정 -> view.changeText(time) 실행 -> 보여주는 View에 Model인 time값을 보여줌 

MVC에 비해 View와 Model 사이에 Presenter가 있어서 분리되었다는 느낌을 줍니다. 하지만 기존의 의존성을 Model에서 Presenter가 가져간 것일뿐입니다.
 
그래서 이러한 의존성을 근본적으로 해결하기 위해서 MVVM 패턴이란것을 사용하게 됩니다.


<13>
MVVM 패턴은 Presenter대신 ViewModel(VM)을 사용합니다. 
ViewModel의 역할은 입력에 해당하는 로직을 처리해서 View에 데이터를 전달합니다.
여기서 핵심은 ViewModel은 View를 참조하지 않기때문에 독립적이라는 것입니다. 따라서 View는 자신이 사용할 ViewModel을 선택해 바인딩해서 업데이트를 받습니다.
바인딩은 다음 DataBinding강의에서 알아봅시다. 이 바인딩을 통해서 View와 ViewModel간 의존성을 없앨 수 있는 것입니다.
그래서 Model이 변경되면 Model을 사용하는 ViewModel에 변경이 생기고 그 ViewModel을 이용하는 View에 전달되어 자동으로 업데이트가 됩니다.

MVVM의 장점은 View와 Model 사이의 의존성이 없고 View와 ViewModel 사이의 의존성도 없습니다.
그리고 중복되는 코드를 모듈화해서 개발할 수 있다는 장점이 있습니다.(ViewModel은 View와 1:N가능)

MVVM사용법은 MVVM 강의에서 함께 알아보도록 합시다.

