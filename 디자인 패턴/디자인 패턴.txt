<1>
이번에는 디자인패턴에 대해 배워봅시다.

<2>
디자인 패턴이란 소프트웨어 개발시 반복적으로 일어나는 문제들을 해결하는 효율적인 방법을 규약을 만들어 정리한 것입니다.
쉽게 말하자면 효율적인 코드를 만들기 위한 방법론이라고 생각할 수 있습니다.
디자인 패턴은 지금껏 소프트웨어 개발 시 발견된 설계의 노하우들이 축적된 규약이기 때문에 다양한 종류가 존재합니다.
이 ppt에서는 제 기준에서 안드로이드에서 자주 사용된다고 생각하는 패턴들을 설명해보겠습니다. 

팩토리 패턴, 옵저버 패턴, Sigleton 패턴, Repository 패턴 이 4가지 패턴에 대해 알아봅시다.

<3>
팩토리 패턴은 팩토리 메소드 패턴과 추상 팩토리 패턴으로 나뉩니다.
팩토리 메소드 패턴은 객체의 인스턴스를 만드는것을 서브 클래스에서 결정하는 패턴이다.
추상 팩토리 패턴은 인터페이스를 이용하여 서로 연관되거나 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있게하는 패턴이다.





<4>
팩토리 메소드 패턴은 클래스의 변경사항이 생겼을 때 다른 클래스에게도 영향을 주는 정도인 결합도를 낮춤으로써 유지보수를 용이하게하고
객체 생성을 캡슐화한다는 이점이있다.
코드에서 팩토리 메소드 패턴을 살펴봅시다.
DesignPatternFactory 파일을 열어서 코드를 봅시다.
DesignPatternFactory 파일은 지금까지 배운 MVVM, LiveData, Room 등이 포함되어 실제 프로젝트에서 사용하는 방식대로 작성된 파일입니다.
MainActivity에서 addButton의 온클릭 리스너를 보면 Animal 객체에 인스턴스를 생성할때 입력값에 따라서 인스턴스를 다르게 생성하는 것을 알 수 있습니다.
만약 지금처럼 cat과 dog 이외에 여러가지 객체들이 존재하고 입력값이 달라질때마다 인스턴스를 다르게 생성해야한다면 어떻게될까요?
코드가 굉장히 복잡해지고 수정할때 어려움이 많을것입니다. 이를 팩토리 메소드 패턴을 사용해서 해결해봅시다.


<5>
먼저 추상 클래스인 AnimalFactory를 생성하여 종별로 Animal 인스턴스를 생성하도록하는 createAniaml 메소드를 구현하도록 합니다.
그 다음 추상 클래스를 구현하는 TypeAnimalFactory를 생성하여 종별로 Animal의 인스턴스를 생성하고 리턴하도록 구현합니다.

<6>
메인에서는 다음과같이 팩토리에 입력값만 넘겨줘서 객체를 반환받습니다.
이렇게하면 메인에서는 어떤 객체가 생성되었는지에 무관하게 생성된 객체만 사용하면 되고 Cat이나 Dog클래스 혹은 다른 클래스가 추가되거나 제거되는 경우가 생기더라도 메인 프로그램에서는 변경이 최소화되는 이점이있습니다.

<7>
다음은 추상 팩토리 패턴을 코드로 알아봅시다.
기존의 AnimalFactory의 createAnimal 메소드의 파리미터를 제거해줍니다. 그 다음
CatFactory와 DogFactory를 만들고 createAnimal 메소드를 정의해줍니다.
그 다음 TypeAnimalFactory를 다음과 같이 바꿔줍니다.

<8>
메인에서는 다음과같이 바꿔줍니다.

추상 팩토리 패턴은 이렇게 팩토리 클래스를 파라미터로 넘겨서 객체를 반환받아 사용하게됩니다. 이 방식은 팩토리 클래스를 교체만으로 기능의 수정이나 확장에 대처할 수 있어 더 코드를 유연하게 만들어줍니다.

<9>
그 다음은 옵저버 패턴에 대해서 알아봅시다.
옵저버 패턴이란 객체의 상태변화를 관찰하는 옵저버들을 객체에 등록하여 상태변화가 있을때마다 메소드 등을 통해서 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 패턴입니다.
조금 쉽게 풀어서 설명하자면 객체의 상태변화를 감지하여 연관된 객체들에게 알림을 보내주는 것이라고 할 수 있습니다.
우리는 주로 LiveData를 쓸때 옵저버 패턴을 사용하게 됩니다. 실제 코드를 보면서 어떻게 사용하는지 봅시다.

<10>
메인 엑티비티에서 viewModel에 있는 dogList, catList에 옵저버를 생성하여 붙여주는 코드입니다.
이 코드는 viewModel에서 다음과같이 dogList와 catList에 변경이 생기면 안에 onChanged 메소드가 실행되게됩니다.

<11>
다음은 Singleton 패턴을 알아봅시다.
Singleton 패턴은 인스턴스가 오직 1개만 생성되게하여 생성된 객체를 어디에서든지 참조할 수 있게 하는 패턴입니다.	
Singleton 패턴의 장점은 메모리를 낭비하지 않고 인스턴스를 사용할 수 있고 전역 인스턴스를 사용하기 때문에 데이터를 공유하기 쉽습니다.
그래서 안드로이드에서는 여러개의 객체생성시 메모리 낭비가 심한 DB작업 혹은 서버에서 API를 불러오는 작업등에 사용됩니다.
하지만 Singleton 패턴을 사용하는 인스턴스가 너무 많은일을 하거나 많은 데이터를 공유하게되면 결합도가 높아지고 멀티쓰레드 환경에서 동기화처리를 안하면 인스턴스가 두개가 생성되는 경우도 발생할 수 있다는 단점이있습니다.
그래서 Singleton 패턴을 사용하는 여러가지 방식을 알아봅시다.

<12>
첫번째 방식은 synchronized를 사용하는 방식입니다. 이 방식은 synchronized 특성상 비교적 큰 성능저하가 발생하여 권장하지 않는 방법입니다.
그래서 이 방식의 성능저하를 완화시키는 두번째 방식을 봅시다.

getInstance 메소드에 바로 synchronized를 사용하는것이 아니라 if문으로 인스턴스의 존재여부를 체크하고 동기화를 시켜 인스턴스를 생성하여 성능저하를 완화한 방식입니다.
하지만 이것보다 더 좋은 방법이 있습니다.

<13>
세번째 방식은 클래스안에 LazyHolder를 사용하는 방식입니다.
이 방법을 사용하면 클래스를 초기화하는 시점을 JVM에넘겨 멀티스레드 환경에서도 안전하게 사용할 수 있고 synchronized를 사용하지 않아 성능도 보장한다.
 
멀티쓰레드 환경에서는 세번째 방식인 LazyHolder를 사용하고 
보통 일반적으로 두번째 방식을 사용해서 Singleton 패턴을 적용한다. 

<14>
다음은 Repository 패턴을 알아봅시다.
repository 패턴이란 데이터가 있는 여러 저장소를 추상화하여 중앙 집중처리 방식을 구성하고, 데이터를 사용하는 로직을 분리시키기 위한 디자인 패턴입니다.

주로 viewModel에서 로컬 DB에 접근하여 데이터를 가져오거나 서버에서 API 응답을 통해 데이터를 가져올때 Repository 패턴을 사용하여 데이터를 가져오게됩니다.
이때 viewModel에서는 데이터가 어디서 오는지 상관없이 제공해주는 데이터만을 이용할 수 있습니다.

실제 코드를 봅시다.

<15>
singleton 패턴과 같이 사용한 코드입니다. setDatabase 메소드로 Database 인스턴스들을 생성해주고 getAnimals 메소드로 데이터베이스에서 데이터를 가져옵니다.
이렇게 데이터를 처리하는 로직들을 repository로 분리시켜 데이터가 추가되어도 repository안에서 변경하여 클래스간 결합도를 낮추고 유지보수성을 향상시킬 수 있습니다.
실제 사용방식과 코드는 프로젝트 파일에서 확인하면 됩니다.